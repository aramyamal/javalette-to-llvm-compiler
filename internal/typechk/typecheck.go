// Package typechk provides tools for type checking the parse tree of a
// Javalette program generated by ANTLR4 parser in the parser package.
// The main entry point is the TypeChecker type, which traverses the parse tree,
// checks for type correctness, and produces a typed abstract syntax tree (TAST)
// using the tast package.
package typechk

import (
	"fmt"

	"github.com/aramyamal/javalette-to-llvm-compiler/gen/parser"
	"github.com/aramyamal/javalette-to-llvm-compiler/internal/tast"
	"github.com/aramyamal/javalette-to-llvm-compiler/pkg/env"
)

// TypeChecker performs type checking on a Javalette program's parse tree, as
// produced by ANTLR4 from package parser. After successful type checking, it
// produces a typed abstract syntax tree using the tast package.
type TypeChecker struct {
	env *env.Environment[tast.Type]
}

// NewTypeChecker creates and returns a new TypeChecker instance.
func NewTypeChecker() *TypeChecker {
	env := env.NewEnvironment[tast.Type]()
	return &TypeChecker{env: env}
}

// Typecheck performs type checking on the given parse tree representing a
// Javalette program. The input should be the root of the parse tree
// (parser.IPrgmContext) as generated by ANTLR4 in the parser package.
//
// If the program is type-correct, it returns a typed abstract syntax
// tree (TAST) using the tast package. If a type error is found, it returns an
// error describing the problem.
func (tc *TypeChecker) Typecheck(tree parser.IPrgmContext) (*tast.Prgm, error) {
	prgm, ok := tree.(*parser.PrgmContext)
	if !ok {
		return nil, fmt.Errorf("expected *parser.ProgramContext, got %T", tree)
	}
	defs := prgm.AllDef()
	if err := validateMainFunc(defs); err != nil {
		return nil, err
	}

	tc.env.AddStdFunc("printInt", tast.Void, tast.Int)
	tc.env.AddStdFunc("printDouble", tast.Void, tast.Double)
	tc.env.AddStdFunc("printString", tast.Void, tast.String)
	tc.env.AddStdFuncNoParam("readInt", tast.Int)
	tc.env.AddStdFuncNoParam("readDouble", tast.Double)

	tc.env.EnterContext()

	if err := validateFuncSigns(tc.env, defs); err != nil {
		return nil, err
	}

	typedDefs, err := tc.checkDefs(prgm.AllDef())
	if err != nil {
		return nil, err
	}

	tc.env.ExitContext()

	typedPrgm := tast.NewPrgm(typedDefs)
	return typedPrgm, nil
}
